# 实现VM管理模块的独立运行和Web界面按钮

## 目标
1. 将vm_management单独运行
2. 在Web页面增加不同模块单独运行的按钮：
   - 1. 准备（读取配置验证配置）
   - 2. 下载KB包
   - 3. KB冲突检测
   - 4. 恢复快照与启动虚拟机（合并多个步骤）
   - 5. 修改IP
   - 6. 恢复客户配置
   - 7. 检测重启
   - 8. 升级KB包
   - 9. KB扫描与报告
3. 实现模块间的数据传递机制，确保依赖模块能正确获取所需信息
4. 增加依赖提示功能，例如在未下载KB包时点击升级或扫描按钮会提示

## 技术可行性分析

### 模块间数据传递
**核心问题**：单模块运行时，如何确保模块之间的数据传递（例如下载KB包后，升级KB包模块需要知道下载的路径和文件名）

**解决方案**：使用文件存储机制
1. **创建状态文件**：`module_state.json`，存储各模块的执行结果和状态
2. **KB包信息存储**：
   - 下载KB包模块将结果存储到 `module_state.json`
   - 包括：`kb_sign_file`、`kb_file_path`、`kb_file_name`、`download_time`
3. **配置状态存储**：
   - 准备模块将验证后的配置存储到 `module_state.json`
   - 包括：配置完整性状态、配置文件路径
4. **虚拟机状态存储**：
   - 存储虚拟机ID、快照ID、运行状态等信息

### 依赖关系处理

**主要依赖关系**：
1. **准备** 是基础依赖：
   - 所有其他模块都依赖于配置的正确性
   - 准备步骤会验证配置文件的完整性

2. **KB包下载** 是基础依赖：
   - 升级KB包依赖于已下载的KB包
   - KB扫描与报告依赖于已下载的KB包

3. **虚拟机状态依赖**：
   - 修改IP依赖于虚拟机已启动
   - 恢复客户配置依赖于虚拟机已启动
   - 升级KB包依赖于虚拟机已启动且网络配置正确
   - KB扫描与报告依赖于虚拟机已启动且网络配置正确

## 实现步骤

### 步骤1：修改vm_management_workflow.py
1. **重构代码结构**：
   - 将主工作流拆分为独立的函数
   - 每个模块创建单独的执行函数
   - 添加命令行参数支持，允许运行特定模块

2. **创建状态管理机制**：
   - 实现 `load_module_state()` 函数
   - 实现 `save_module_state()` 函数
   - 使用 `module_state.json` 存储模块执行状态

3. **创建独立模块函数**：
   - `prepare()` - 加载配置验证配置（独立模块）
   - `download_kb_package()` - 下载KB包
   - `check_kb_conflicts()` - KB冲突检测
   - `recover_snapshot_and_start_vm()` - 恢复快照并启动虚拟机
   - `modify_vm_ip_address()` - 修改虚拟机IP
   - `recover_customer_config()` - 恢复客户配置
   - `check_vm_reboot()` - 检测虚拟机重启
   - `upgrade_kb_package()` - 升级KB包
   - `run_kb_scan_and_report()` - KB扫描与报告

4. **添加依赖检查**：
   - 在每个模块执行前检查依赖条件
   - 例如：升级KB包前检查KB包是否已下载
   - 例如：修改IP前检查虚拟机是否已启动

### 步骤2：更新config_web.py
1. **前端界面修改**：
   - 在actions部分添加新的模块按钮，包括"准备"按钮
   - 为每个按钮创建单独的表单提交
   - 保持现有的样式和布局
   - 添加依赖关系提示，例如禁用依赖未满足的按钮
   - 实现JavaScript验证，在点击依赖按钮时显示提示

2. **后端功能实现**：
   - 添加新的路由处理函数
   - 为每个模块创建单独的执行函数
   - 实现线程化执行，避免阻塞Web界面
   - 添加模块执行状态跟踪

3. **状态管理**：
   - 扩展现有状态管理，支持多模块执行
   - 为每个模块添加独立的输出跟踪
   - 实现模块执行状态的实时更新

### 步骤3：集成KB相关功能
1. **整合KB.py**：
   - 调用KB.py的下载功能
   - 处理KB包下载的结果
   - 将下载结果存储到 `module_state.json`

2. **整合KB_compare.py**：
   - 调用KB冲突检测功能
   - 展示冲突检测结果

3. **整合KB_scan.py和KB_scan_report.py**：
   - 调用KB扫描功能
   - 生成并展示扫描报告

### 步骤4：添加依赖检查和错误处理
1. **前端依赖检查**：
   - 在Web界面中添加JavaScript验证
   - 当依赖未满足时，点击按钮会显示提示而不是执行
   - 例如：点击KB包升级按钮时，检查KB包是否已下载
   - 例如：点击其他模块按钮时，检查是否已执行准备步骤

2. **后端依赖检查**：
   - 在每个模块执行前检查依赖条件
   - 如果依赖未满足，返回错误信息

3. **错误处理**：
   - 完善每个模块的错误处理
   - 添加详细的错误日志
   - 在Web界面中展示友好的错误信息

### 步骤5：测试与验证
1. **功能测试**：
   - 测试每个模块的独立运行
   - 验证Web界面按钮功能
   - 测试模块间的依赖关系处理
   - 测试依赖提示功能
   - 测试数据传递机制（例如下载KB包后升级KB包）

2. **边界情况测试**：
   - 测试配置缺失的情况
   - 测试网络连接失败的情况
   - 测试模块执行失败的处理
   - 测试依赖未满足时的处理

## 技术实现要点
- **模块化设计**：确保每个模块可以独立运行
- **状态管理**：使用文件存储机制实现模块间数据传递
- **依赖管理**：正确处理模块间的依赖关系
- **线程安全**：使用线程池管理并发执行
- **错误处理**：完善的错误捕获和日志记录
- **用户体验**：实时状态更新和友好的错误提示
- **代码复用**：最大限度复用现有代码，减少重复

## 预期结果
- Web界面增加9个独立模块按钮，包括"准备"按钮
- 每个模块可以单独运行，不受其他模块影响
- 模块间的数据传递机制正常工作，例如：
  - 下载KB包后，升级KB包模块能正确获取下载路径和文件名
  - 恢复快照后，修改IP模块能正确获取虚拟机信息
- 依赖未满足时显示友好提示
- vm_management可以作为独立模块运行
- 所有功能保持与原有系统的兼容性